#!/usr/bin/env python
# coding: utf-8

# In[12]:


import get_x
import reccomend 

class reccomend_test:


    def test_graph_positive():
        adj_df = load_data()[0]
        graph = build_network(adj_df)
        grah_sum = graph.sum()
        if graph_sum > 0:
            assert f'graph is non zero, image classifier at least sorta worked'


    def test_name_format(adj_df):
        '''
        tests to see if all column names of the adjacency matrix generated by image classifer have the proper format 
        '''

        lst = []
        adj_df = load_data()[0]
        article_nms = lst(adj_df.columns)
        for article in article_nms:
            yes_no =  '_' in article
            lst.append(yes_no)
        actual = sum(lst)
        expected = len(adj_df.columns)
        assert actual == expected, f'every column of adjaceny matrix contains the proper format'


    def test_similar():
        '''
        tests to make sure all similarity values are in between 1 and 0 or math is wrong. 

        '''
        adj_df, wardrobe = load_data()
        graph, pieces = build_network(adj_df)
        wardrobe_index = [pieces.index(x) for x in wardrobe]
        wardrobe_graph = graph[:, wardrobe_index]
        similar_scores = reccomend.similarity(graph, wardrobe_graph, pieces)
        correct_vals = [x for x in similar_scores if x < 1 and x > 0]
        expected = len(similar_scores)
        actual = len(correct_vals)
        assert exepected == actual, f'similarity scores are bounded between 0 and 1'


    def test_difference():
        '''
        tests to make sure all differentiation values are in between 1 and 0 or math is wrong. 

        '''

        adj_df, wardobe = load_data()
        graph, pieces = build_network(adj_df)
        wardrobe_index = [pieces.index(x) for x in wardrobe]
        wardrobe_graph = graph[:, wardrobe_index]
        diff_scores = reccomend.difference()
        correct_vals = [x for x in similar_scores if x < 1 and x > 0]
        expected = len(similar_scores)
        actual = len(correct_vals)
        assert exepected == actual, f'differentiation scores are bounded between 0 and 1'
        
   
    def main():
        test_graph_positive()
        test_name_format()
        test_similar()
        test_difference()
        
        

    
class get_x_test:
    
    def test_query():
        """
        Checks to see if get_final successfully retreived all data: text, data, metrics, and images for all tweets. 

        """ 
        id="276332668"
        endpoint = get_final(id)
        keys = endpoint.keys()
        for key in keys:
            actual = len(endpoint[key])
            expected = 4
            assert  actual == expected


    
    
    def test_metrics():
        """
        Checks to make sure that the index is the proper length of 10 so that it can index all returned tweets. 
        I ran into this problem when the code was slightly out of order
        """
        id="276332668"
        dic = get_final(id)
        met = get_metrics(dic)
        for key in met.keys():
            actual = len(met[key])
            expected = 10
            assert actual == expected 


    def test_get_data():
        """
        Checks to make sure that each api query with the current parameters is still returning results. 
        This may be useful, as I discovered, api's get updated and perhaps the fields are no longer valid. 
        """
        id="276332668"
        queries = ['lst', 'users', 'tweets']
        for q in queries:
            print(f'the loop got stuck on the query type of{q}') #will tell whhic value it failed on
            params = parameters(query = q)
            url = create_url(query = q, id = id)
            response = requests.request("GET", url, auth=bearer_oauth, params=params)
            if response.status_code == 400:
                raise Exception("Request returned an error: {} {}. In other words the parameters I'm using for query of type {q} may be bad. Consider checking the twitter documentation and checking the top of the no_scroll src code file to see if they are still valid".format(response.status_code, response.text
                                                     )
            )
                
    
    def main():
        test_query()
        test_metrics()
        test_get_data()




if __name__ == "__main__":
    reccomend_test.main()
    get_x_test.main()
 

